<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>BadgerDB: badgerdb::BTreeIndex Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">BadgerDB
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacebadgerdb.html">badgerdb</a>      </li>
      <li class="navelem"><a class="el" href="classbadgerdb_1_1_b_tree_index.html">BTreeIndex</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">badgerdb::BTreeIndex Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="badgerdb::BTreeIndex" -->
<p><a class="el" href="classbadgerdb_1_1_b_tree_index.html" title="BTreeIndex class. It implements a B+ Tree index on a single attribute of a relation. This index supports only one scan at a time.">BTreeIndex</a> class. It implements a B+ Tree index on a single attribute of a relation. This index supports only one scan at a time.  
 <a href="classbadgerdb_1_1_b_tree_index.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="btree_8h_source.html">btree.h</a>&gt;</code></p>

<p><a href="classbadgerdb_1_1_b_tree_index-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbadgerdb_1_1_b_tree_index.html#a4867de84c5392d9df9cb54438dd35d38">BTreeIndex</a> (const std::string &amp;relationName, std::string &amp;outIndexName, <a class="el" href="classbadgerdb_1_1_buf_mgr.html">BufMgr</a> *bufMgrIn, const int attrByteOffset, const <a class="el" href="namespacebadgerdb.html#a9dc9c8fe64ff894720886ba4b9f81f4b">Datatype</a> attrType)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbadgerdb_1_1_b_tree_index.html#ad6a15bba5c82d90e316dd6a1a10cc52a">~BTreeIndex</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbadgerdb_1_1_b_tree_index.html#a37ae558488f4080dfdfaf24098192cd3">insertEntry</a> (const void *key, const <a class="el" href="structbadgerdb_1_1_record_id.html">RecordId</a> rid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98df485083deefd0d6a1246206fa3c1b"></a><!-- doxytag: member="badgerdb::BTreeIndex::insertEntryRecursive" ref="a98df485083deefd0d6a1246206fa3c1b" args="(RIDKeyPair&lt; int &gt; ridKeyPair, PageId pageId, bool isLeaf, int &amp;newValue, PageId &amp;newPage)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>insertEntryRecursive</b> (<a class="el" href="classbadgerdb_1_1_r_i_d_key_pair.html">RIDKeyPair</a>&lt; int &gt; ridKeyPair, <a class="el" href="namespacebadgerdb.html#a1f49e404293bf4240756b89b53b1587a">PageId</a> pageId, bool isLeaf, int &amp;newValue, <a class="el" href="namespacebadgerdb.html#a1f49e404293bf4240756b89b53b1587a">PageId</a> &amp;newPage)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbadgerdb_1_1_b_tree_index.html#aa0426d99197f0ad5b2054df595243437">startScan</a> (const void *lowVal, const <a class="el" href="namespacebadgerdb.html#aad50f9c7a9ef0cbcfe0b025a7aa5cb28">Operator</a> lowOp, const void *highVal, const <a class="el" href="namespacebadgerdb.html#aad50f9c7a9ef0cbcfe0b025a7aa5cb28">Operator</a> highOp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbadgerdb_1_1_b_tree_index.html#a0834ba4655cac7af31ce1b8f2f18f0e1">scanNext</a> (<a class="el" href="structbadgerdb_1_1_record_id.html">RecordId</a> &amp;outRid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbadgerdb_1_1_b_tree_index.html#a78093b184e3ed6faf6edd8e90010583b">endScan</a> ()</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classbadgerdb_1_1_b_tree_index.html" title="BTreeIndex class. It implements a B+ Tree index on a single attribute of a relation. This index supports only one scan at a time.">BTreeIndex</a> class. It implements a B+ Tree index on a single attribute of a relation. This index supports only one scan at a time. </p>

<p>Definition at line <a class="el" href="btree_8h_source.html#l00296">296</a> of file <a class="el" href="btree_8h_source.html">btree.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4867de84c5392d9df9cb54438dd35d38"></a><!-- doxytag: member="badgerdb::BTreeIndex::BTreeIndex" ref="a4867de84c5392d9df9cb54438dd35d38" args="(const std::string &amp;relationName, std::string &amp;outIndexName, BufMgr *bufMgrIn, const int attrByteOffset, const Datatype attrType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbadgerdb_1_1_b_tree_index.html#a4867de84c5392d9df9cb54438dd35d38">badgerdb::BTreeIndex::BTreeIndex</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>relationName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>outIndexName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbadgerdb_1_1_buf_mgr.html">BufMgr</a> *&#160;</td>
          <td class="paramname"><em>bufMgrIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>attrByteOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebadgerdb.html#a9dc9c8fe64ff894720886ba4b9f81f4b">Datatype</a>&#160;</td>
          <td class="paramname"><em>attrType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classbadgerdb_1_1_b_tree_index.html" title="BTreeIndex class. It implements a B+ Tree index on a single attribute of a relation. This index supports only one scan at a time.">BTreeIndex</a> Constructor. Check to see if the corresponding index file exists. If so, open the file. If not, create it and insert entries for every tuple in the base relation using <a class="el" href="classbadgerdb_1_1_file_scan.html" title="This class is used to sequentially scan records in a relation.">FileScan</a> class.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">relationName</td><td>Name of file. </td></tr>
    <tr><td class="paramname">outIndexName</td><td>Return the name of index file. </td></tr>
    <tr><td class="paramname">bufMgrIn</td><td>Buffer Manager Instance </td></tr>
    <tr><td class="paramname">attrByteOffset</td><td>Offset of attribute, over which index is to be built, in the record </td></tr>
    <tr><td class="paramname">attrType</td><td>Datatype of attribute over which index is built </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classbadgerdb_1_1_bad_index_info_exception.html" title="An exception that is thrown when a file operation is requested for a filename that doesn&#39;t exist...">BadIndexInfoException</a></td><td>If the index file already exists for the corresponding attribute, but values in metapage(relationName, attribute byte offset, attribute type etc.) do not match with values received through constructor parameters. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="btree_8cpp_source.html#l00030">30</a> of file <a class="el" href="btree_8cpp_source.html">btree.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  std::ostringstream idxStr;
  idxStr &lt;&lt; relationName &lt;&lt; <span class="charliteral">&#39;.&#39;</span> &lt;&lt; attrByteOffset;
  outIndexName = idxStr.str();

  this-&gt;bufMgr = bufMgrIn;
  this-&gt;attrByteOffset = attrByteOffset;
  this-&gt;attributeType = attrType;

  <span class="keywordflow">try</span>{
    <span class="comment">//metadata page</span>
    file = <span class="keyword">new</span> BlobFile(outIndexName, <span class="keyword">true</span>);
    Page* page;
    bufMgrIn-&gt;allocPage(file, headerPageNum, page);
    IndexMetaInfo* indexMetaInfo = (IndexMetaInfo*) page;
    indexMetaInfo-&gt;rootPageNo = rootPageNum;
    indexMetaInfo-&gt;attrByteOffset = attrByteOffset;
    indexMetaInfo-&gt;attrType = attrType;
    strcpy(indexMetaInfo-&gt;relationName, relationName.c_str());
    bufMgrIn-&gt;unPinPage(file, headerPageNum, <span class="keyword">true</span>);

    <span class="comment">//root page</span>
    bufMgrIn-&gt;allocPage(file, rootPageNum, page);
    <span class="keywordflow">switch</span> (attrType) {
      <span class="keywordflow">case</span> INTEGER: {
        NonLeafNodeInt *nonLeafNodeInt = (NonLeafNodeInt *) page;
        nonLeafNodeInt-&gt;level = 1;
        <span class="keywordflow">break</span>;
      }
      <span class="keywordflow">case</span> DOUBLE: {
        NonLeafNodeDouble *nonLeafNodeDouble = (NonLeafNodeDouble *) page;
        nonLeafNodeDouble-&gt;level = 1;
        <span class="keywordflow">break</span>;
      }
      <span class="keywordflow">case</span> STRING: {
        NonLeafNodeString *nonLeafNodeString = (NonLeafNodeString *) page;
        nonLeafNodeString-&gt;level = 1;
        <span class="keywordflow">break</span>;
      }
      <span class="keywordflow">default</span>:
        <span class="keywordflow">break</span>;
    }
    bufMgrIn-&gt;unPinPage(file, rootPageNum, <span class="keyword">true</span>);

    <span class="comment">//insert index</span>
    FileScan fscan(relationName, bufMgr);
    RecordId scanRid;
    <span class="keywordflow">while</span>(1)
    {
      fscan.scanNext(scanRid);
      <a class="code" href="classbadgerdb_1_1_b_tree_index.html#a37ae558488f4080dfdfaf24098192cd3">insertEntry</a>((<span class="keywordtype">void</span> *) fscan.getRecord().c_str() + attrByteOffset, scanRid);  <span class="comment">//TODO:?</span>
    }
  }
  <span class="keywordflow">catch</span> (FileExistsException e){
    this-&gt;file = <span class="keyword">new</span> BlobFile(outIndexName, <span class="keyword">false</span>);
    Page* page;
    headerPageNum = 1;
    bufMgrIn-&gt;readPage(file, headerPageNum, page);
    IndexMetaInfo* indexMetaInfo = (IndexMetaInfo*) page;

    <span class="comment">//check</span>
    <span class="keywordflow">if</span>(indexMetaInfo-&gt;attrByteOffset != attrByteOffset
       || indexMetaInfo-&gt;attrType != attrType
       || !strcmp(indexMetaInfo-&gt;relationName, relationName.c_str()))
      <span class="keywordflow">throw</span> BadIndexInfoException(<span class="stringliteral">&quot;constructor parameters do not match exist index file&quot;</span>);

    this-&gt;rootPageNum = indexMetaInfo-&gt;rootPageNo;
    bufMgrIn-&gt;unPinPage(file, headerPageNum, <span class="keyword">false</span>);
  }
  <span class="keywordflow">catch</span> (EndOfFileException e){
    std::cout &lt;&lt; <span class="stringliteral">&quot;Finish Read all records //Gu&quot;</span>
    &lt;&lt; <span class="stringliteral">&quot;hearpage: &quot;</span> &lt;&lt; headerPageNum &lt;&lt; <span class="stringliteral">&quot;rootpage:&quot;</span> &lt;&lt; rootPageNum&lt;&lt; std::endl; <span class="comment">//TODO: delete</span>
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad6a15bba5c82d90e316dd6a1a10cc52a"></a><!-- doxytag: member="badgerdb::BTreeIndex::~BTreeIndex" ref="ad6a15bba5c82d90e316dd6a1a10cc52a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbadgerdb_1_1_b_tree_index.html#ad6a15bba5c82d90e316dd6a1a10cc52a">badgerdb::BTreeIndex::~BTreeIndex</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classbadgerdb_1_1_b_tree_index.html" title="BTreeIndex class. It implements a B+ Tree index on a single attribute of a relation. This index supports only one scan at a time.">BTreeIndex</a> Destructor. End any initialized scan, flush index file, after unpinning any pinned pages, from the buffer manager and delete file instance thereby closing the index file. Destructor should not throw any exceptions. All exceptions should be caught in here itself. </p>

<p>Definition at line <a class="el" href="btree_8cpp_source.html#l00115">115</a> of file <a class="el" href="btree_8cpp_source.html">btree.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a78093b184e3ed6faf6edd8e90010583b"></a><!-- doxytag: member="badgerdb::BTreeIndex::endScan" ref="a78093b184e3ed6faf6edd8e90010583b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void <a class="el" href="classbadgerdb_1_1_b_tree_index.html#a78093b184e3ed6faf6edd8e90010583b">badgerdb::BTreeIndex::endScan</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Terminate the current scan. Unpin any pinned pages. Reset scan specific variables. </p>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classbadgerdb_1_1_scan_not_initialized_exception.html" title="An exception that is thrown when a file operation is requested for a filename that doesn&#39;t exist...">ScanNotInitializedException</a></td><td>If no scan has been initialized. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="btree_8cpp_source.html#l00545">545</a> of file <a class="el" href="btree_8cpp_source.html">btree.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  scanExecuting = <span class="keyword">false</span>;
  bufMgr-&gt;<a class="code" href="classbadgerdb_1_1_buf_mgr.html#aa9bdf04c8543f59744db22efa9420c89">unPinPage</a>(file, currentPageNum, <span class="keyword">false</span>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a37ae558488f4080dfdfaf24098192cd3"></a><!-- doxytag: member="badgerdb::BTreeIndex::insertEntry" ref="a37ae558488f4080dfdfaf24098192cd3" args="(const void *key, const RecordId rid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void <a class="el" href="classbadgerdb_1_1_b_tree_index.html#a37ae558488f4080dfdfaf24098192cd3">badgerdb::BTreeIndex::insertEntry</a> </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbadgerdb_1_1_record_id.html">RecordId</a>&#160;</td>
          <td class="paramname"><em>rid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert a new entry using the pair &lt;value,rid&gt;. Start from root to recursively find out the leaf to insert the entry in. The insertion may cause splitting of leaf node. This splitting will require addition of new leaf page number entry into the parent non-leaf, which may in-turn get split. This may continue all the way upto the root causing the root to get split. If root gets split, metapage needs to be changed accordingly. Make sure to unpin pages as soon as you can. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to insert, pointer to integer/double/char string </td></tr>
    <tr><td class="paramname">rid</td><td>Record ID of a record whose entry is getting inserted into the index. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="btree_8cpp_source.html#l00406">406</a> of file <a class="el" href="btree_8cpp_source.html">btree.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  Page *page;
  bufMgr-&gt;<a class="code" href="classbadgerdb_1_1_buf_mgr.html#a9f853f0f1d4628e7e14374d0c7c6a4f3">readPage</a>(file, rootPageNum, page);
  <span class="keywordflow">switch</span> (attributeType){
    <span class="keywordflow">case</span> INTEGER:{
      RIDKeyPair&lt;int &gt; ridKeyPair;
      ridKeyPair.set(rid, *((<span class="keywordtype">int</span> *) key));
      <span class="keywordtype">int</span> newValue;
      <a class="code" href="namespacebadgerdb.html#a1f49e404293bf4240756b89b53b1587a" title="Identifier for a page in a file.">PageId</a> newPageId = 0;
      insertEntryRecursive(ridKeyPair, rootPageNum, 0, newValue, newPageId);

      <span class="comment">//if root got split</span>
      <span class="keywordflow">if</span>(newPageId != 0){
        <a class="code" href="namespacebadgerdb.html#a1f49e404293bf4240756b89b53b1587a" title="Identifier for a page in a file.">PageId</a> newRootPageId;
        Page* newRootPage;
        bufMgr-&gt;<a class="code" href="classbadgerdb_1_1_buf_mgr.html#ab9ae3b12aac55b119b5763e3de2a4d2b">allocPage</a>(file, newRootPageId, newRootPage);
        NonLeafNodeInt* newRootNonLeafNodeInt = (NonLeafNodeInt*) page;
        newRootNonLeafNodeInt-&gt;keyArray[0] = newValue;
        newRootNonLeafNodeInt-&gt;pageNoArray[0] = rootPageNum;
        newRootNonLeafNodeInt-&gt;pageNoArray[1] = newPageId;
        newRootNonLeafNodeInt-&gt;level = 0;
        rootPageNum = newRootPageId;
        bufMgr-&gt;<a class="code" href="classbadgerdb_1_1_buf_mgr.html#aa9bdf04c8543f59744db22efa9420c89">unPinPage</a>(file, newRootPageId, <span class="keyword">true</span>);
      }
    }
    <span class="keywordflow">case</span> DOUBLE:{
      RIDKeyPair&lt;double &gt; ridKeyPair;
      ridKeyPair.set(rid, *((<span class="keywordtype">double</span> *) key));
      <span class="keywordtype">double</span> newValue;
      <a class="code" href="namespacebadgerdb.html#a1f49e404293bf4240756b89b53b1587a" title="Identifier for a page in a file.">PageId</a> newPageId = 0;
<span class="comment">//      insertEntryRecursive(ridKeyPair, rootPageNum, 0, newValue, newPageId);</span>
      <span class="comment">//TODO: root split</span>

    }
    <span class="keywordflow">case</span> STRING:{
      RIDKeyPair&lt;char[STRINGSIZE] &gt; ridKeyPair;
      strncpy(ridKeyPair.key, (<span class="keywordtype">char</span>*) key, <a class="code" href="namespacebadgerdb.html#a963f341a4f5c2c97cc2e4ffc7b0aa459" title="Size of String key.">STRINGSIZE</a>);
      ridKeyPair.rid = rid;
      <span class="keywordtype">char</span> newValue[<a class="code" href="namespacebadgerdb.html#a963f341a4f5c2c97cc2e4ffc7b0aa459" title="Size of String key.">STRINGSIZE</a>];
      <a class="code" href="namespacebadgerdb.html#a1f49e404293bf4240756b89b53b1587a" title="Identifier for a page in a file.">PageId</a> newPageId = 0;
<span class="comment">//      insertEntryRecursive(ridKeyPair, rootPageNum, 0, newValue, newPageId);</span>
      <span class="comment">//TODO: root split</span>


    }
  }


}
</pre></div>
</div>
</div>
<a class="anchor" id="a0834ba4655cac7af31ce1b8f2f18f0e1"></a><!-- doxytag: member="badgerdb::BTreeIndex::scanNext" ref="a0834ba4655cac7af31ce1b8f2f18f0e1" args="(RecordId &amp;outRid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void <a class="el" href="classbadgerdb_1_1_b_tree_index.html#a0834ba4655cac7af31ce1b8f2f18f0e1">badgerdb::BTreeIndex::scanNext</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbadgerdb_1_1_record_id.html">RecordId</a> &amp;&#160;</td>
          <td class="paramname"><em>outRid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch the record id of the next index entry that matches the scan. Return the next record from current page being scanned. If current page has been scanned to its entirety, move on to the right sibling of current page, if any exists, to start scanning that page. Make sure to unpin any pages that are no longer required. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">outRid</td><td><a class="el" href="structbadgerdb_1_1_record_id.html" title="Identifier for a record in a page.">RecordId</a> of next record found that satisfies the scan criteria returned in this </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classbadgerdb_1_1_scan_not_initialized_exception.html" title="An exception that is thrown when a file operation is requested for a filename that doesn&#39;t exist...">ScanNotInitializedException</a></td><td>If no scan has been initialized. </td></tr>
    <tr><td class="paramname"><a class="el" href="classbadgerdb_1_1_index_scan_completed_exception.html" title="An exception that is thrown when a file operation is requested for a filename that doesn&#39;t exist...">IndexScanCompletedException</a></td><td>If no more records, satisfying the scan criteria, are left to be scanned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="btree_8cpp_source.html#l00504">504</a> of file <a class="el" href="btree_8cpp_source.html">btree.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">switch</span> (attributeType){
    <span class="keywordflow">case</span> INTEGER:{
      LeafNodeInt* leafNodeInt;
      <span class="keywordflow">while</span>(1){
        leafNodeInt = (LeafNodeInt*) currentPageData;
        <span class="keywordflow">if</span>(leafNodeInt-&gt;ridArray[nextEntry].page_number == 0
            || nextEntry == <a class="code" href="namespacebadgerdb.html#a2195ac9af2c5aa506d1b6ca42ac503f9" title="Number of key slots in B+Tree leaf for INTEGER key.">INTARRAYLEAFSIZE</a>) {
          bufMgr-&gt;<a class="code" href="classbadgerdb_1_1_buf_mgr.html#aa9bdf04c8543f59744db22efa9420c89">unPinPage</a>(file, currentPageNum, <span class="keyword">false</span>);

          currentPageNum = leafNodeInt-&gt;rightSibPageNo;
          <span class="keywordflow">if</span>(currentPageNum == 0)
            <span class="keywordflow">throw</span> IndexScanCompletedException();

          std::cout&lt;&lt;<span class="stringliteral">&quot;scan next try to read page&quot;</span>&lt;&lt;currentPageNum;
          bufMgr-&gt;<a class="code" href="classbadgerdb_1_1_buf_mgr.html#a9f853f0f1d4628e7e14374d0c7c6a4f3">readPage</a>(file, currentPageNum, currentPageData);
          <span class="keywordflow">continue</span>;
        }

        <span class="keywordflow">if</span>((lowOp==GT &amp;&amp; leafNodeInt-&gt;keyArray[nextEntry] &lt;= lowValInt)
            || (lowOp==GTE &amp;&amp; leafNodeInt-&gt;keyArray[nextEntry] &lt; lowValInt)
            || (highOp==LT &amp;&amp; leafNodeInt-&gt;keyArray[nextEntry] &gt;= highValInt)
            || (highOp==LTE &amp;&amp; leafNodeInt-&gt;keyArray[nextEntry] &gt; highValInt))
        {
          nextEntry++;
          <span class="keywordflow">continue</span>;
        }

        outRid = leafNodeInt-&gt;ridArray[nextEntry];
        nextEntry++;
        return ;
      }
    }
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa0426d99197f0ad5b2054df595243437"></a><!-- doxytag: member="badgerdb::BTreeIndex::startScan" ref="aa0426d99197f0ad5b2054df595243437" args="(const void *lowVal, const Operator lowOp, const void *highVal, const Operator highOp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void <a class="el" href="classbadgerdb_1_1_b_tree_index.html#aa0426d99197f0ad5b2054df595243437">badgerdb::BTreeIndex::startScan</a> </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>lowVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebadgerdb.html#aad50f9c7a9ef0cbcfe0b025a7aa5cb28">Operator</a>&#160;</td>
          <td class="paramname"><em>lowOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>highVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebadgerdb.html#aad50f9c7a9ef0cbcfe0b025a7aa5cb28">Operator</a>&#160;</td>
          <td class="paramname"><em>highOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begin a filtered scan of the index. For instance, if the method is called using ("a",GT,"d",LTE) then we should seek all entries with a value greater than "a" and less than or equal to "d". If another scan is already executing, that needs to be ended here. Set up all the variables for scan. Start from root to find out the leaf page that contains the first RecordID that satisfies the scan parameters. Keep that page pinned in the buffer pool. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lowVal</td><td>Low value of range, pointer to integer / double / char string </td></tr>
    <tr><td class="paramname">lowOp</td><td>Low operator (GT/GTE) </td></tr>
    <tr><td class="paramname">highVal</td><td>High value of range, pointer to integer / double / char string </td></tr>
    <tr><td class="paramname">highOp</td><td>High operator (LT/LTE) </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classbadgerdb_1_1_bad_opcodes_exception.html" title="An exception that is thrown when some unexpected error occurs in the hash table.">BadOpcodesException</a></td><td>If lowOp and highOp do not contain one of their their expected values </td></tr>
    <tr><td class="paramname"><a class="el" href="classbadgerdb_1_1_bad_scanrange_exception.html" title="An exception that is thrown when some unexpected error occurs in the hash table.">BadScanrangeException</a></td><td>If lowVal &gt; highval </td></tr>
    <tr><td class="paramname"><a class="el" href="classbadgerdb_1_1_no_such_key_found_exception.html" title="An exception that is thrown when a file operation is requested for a filename that doesn&#39;t exist...">NoSuchKeyFoundException</a></td><td>If there is no key in the B+ tree that satisfies the scan criteria. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="btree_8cpp_source.html#l00461">461</a> of file <a class="el" href="btree_8cpp_source.html">btree.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  scanExecuting = <span class="keyword">true</span>;

  <span class="keywordflow">switch</span> (attributeType) {
    <span class="keywordflow">case</span> INTEGER:{
      this-&gt;lowOp = lowOpParm;
      this-&gt;highOp = highOpParm;
      this-&gt;lowValInt = *((<span class="keywordtype">int</span>*) lowValParm);
      this-&gt;highValInt = *((<span class="keywordtype">int</span> *) highValParm);
    }
  }

  <span class="comment">//find first one</span>
  currentPageNum = rootPageNum;
  bufMgr-&gt;<a class="code" href="classbadgerdb_1_1_buf_mgr.html#a9f853f0f1d4628e7e14374d0c7c6a4f3">readPage</a>(file, currentPageNum, currentPageData);
  std::cout&lt;&lt; <span class="stringliteral">&quot;start scan, open rootpage&quot;</span>&lt;&lt; std::endl;  <span class="comment">//TODO:delete</span>
  NonLeafNodeInt* nonLeafNodeInt = (NonLeafNodeInt*) currentPageData;

  <span class="keywordflow">while</span>(nonLeafNodeInt-&gt;level != 1) {
    bufMgr-&gt;<a class="code" href="classbadgerdb_1_1_buf_mgr.html#a9f853f0f1d4628e7e14374d0c7c6a4f3">readPage</a>(file, nonLeafNodeInt-&gt;pageNoArray[0], currentPageData);
    bufMgr-&gt;<a class="code" href="classbadgerdb_1_1_buf_mgr.html#aa9bdf04c8543f59744db22efa9420c89">unPinPage</a>(file, currentPageNum, <span class="keyword">false</span>);
    currentPageNum = nonLeafNodeInt-&gt;pageNoArray[0];
    nonLeafNodeInt = (NonLeafNodeInt*) currentPageData;
  }
  bufMgr-&gt;<a class="code" href="classbadgerdb_1_1_buf_mgr.html#a9f853f0f1d4628e7e14374d0c7c6a4f3">readPage</a>(file, nonLeafNodeInt-&gt;pageNoArray[0], currentPageData);
  bufMgr-&gt;<a class="code" href="classbadgerdb_1_1_buf_mgr.html#aa9bdf04c8543f59744db22efa9420c89">unPinPage</a>(file, currentPageNum, <span class="keyword">false</span>);
  currentPageNum = nonLeafNodeInt-&gt;pageNoArray[0];
  nonLeafNodeInt = (NonLeafNodeInt*) currentPageData;

  nextEntry = 0;

  std::cout&lt;&lt; <span class="stringliteral">&quot;start scan complete&quot;</span> &lt;&lt; std::endl
  &lt;&lt;<span class="stringliteral">&quot;current page:&quot;</span>&lt;&lt;currentPageNum &lt;&lt; std::endl; <span class="comment">//TODO:delete</span>
}
</pre></div>
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/afs/cs.wisc.edu/u/z/h/zhichenggu/db/pro4/BTree/src/<a class="el" href="btree_8h_source.html">btree.h</a></li>
<li>/afs/cs.wisc.edu/u/z/h/zhichenggu/db/pro4/BTree/src/<a class="el" href="btree_8cpp_source.html">btree.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 2 2015 22:13:54 for BadgerDB by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
